"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */
// tslint:disable:no-shadowed-variable prefer-for-of
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = require("./util");
/** Node that represents a type. */
var TType = /** @class */ (function () {
    function TType() {
    }
    return TType;
}());
exports.TType = TType;
/** Parses a type spec into a TType node. */
function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) {
        throw new Error("Unknown type " + name);
    }
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */
function name(value) { return new TName(value); }
exports.name = name;
var TName = /** @class */ (function (_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) {
            return checker;
        }
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
    };
    return TName;
}(TType));
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */
function lit(value) { return new TLiteral(value); }
exports.lit = lit;
var TLiteral = /** @class */ (function (_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TLiteral;
}(TType));
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */
function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
exports.array = array;
var TArray = /** @class */ (function (_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function (suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < value.length; i++) {
                var ok = itemChecker(value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
    };
    return TArray;
}(TType));
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */
function tuple() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.tuple = tuple;
var TTuple = /** @class */ (function (_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function (suite, strict) {
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType));
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */
function union() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.union = union;
var TUnion = /** @class */ (function (_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
            .filter(function (n) { return n; });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) {
                names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
        }
        else {
            _this._failMsg = "is none of " + otherTypes + " types";
        }
        return _this;
    }
    TUnion.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        return function (value, ctx) {
            var ur = ctx.unionResolver();
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) {
                    return true;
                }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType));
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */
function intersection() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.intersection = intersection;
var TIntersection = /** @class */ (function (_super) {
    __extends(TIntersection, _super);
    function TIntersection(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TIntersection.prototype.getChecker = function (suite, strict) {
        var allowedProps = new Set();
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });
        return function (value, ctx) {
            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });
            if (ok) {
                return true;
            }
            return ctx.fail(null, null, 0);
        };
    };
    return TIntersection;
}(TType));
exports.TIntersection = TIntersection;
/**
 * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).
 */
function enumtype(values) {
    return new TEnumType(values);
}
exports.enumtype = enumtype;
var TEnumType = /** @class */ (function (_super) {
    __extends(TEnumType, _super);
    function TEnumType(members) {
        var _this = _super.call(this) || this;
        _this.members = members;
        _this.validValues = new Set();
        _this._failMsg = "is not a valid enum value";
        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));
        return _this;
    }
    TEnumType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) {
            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));
        };
    };
    return TEnumType;
}(TType));
exports.TEnumType = TEnumType;
/**
 * Defines a literal enum value, such as Direction.Up, specified as enumlit("Direction", "Up").
 */
function enumlit(name, prop) {
    return new TEnumLiteral(name, prop);
}
exports.enumlit = enumlit;
var TEnumLiteral = /** @class */ (function (_super) {
    __extends(TEnumLiteral, _super);
    function TEnumLiteral(enumName, prop) {
        var _this = _super.call(this) || this;
        _this.enumName = enumName;
        _this.prop = prop;
        _this._failMsg = "is not " + enumName + "." + prop;
        return _this;
    }
    TEnumLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var ttype = getNamedType(suite, this.enumName);
        if (!(ttype instanceof TEnumType)) {
            throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        }
        var val = ttype.members[this.prop];
        if (!ttype.members.hasOwnProperty(this.prop)) {
            throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        }
        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TEnumLiteral;
}(TType));
exports.TEnumLiteral = TEnumLiteral;
function makeIfaceProps(props) {
    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });
}
function makeIfaceProp(name, prop) {
    return prop instanceof TOptional ?
        new TProp(name, prop.ttype, true) :
        new TProp(name, parseSpec(prop), false);
}
/**
 * Defines an interface. The first argument is an array of interfaces that it extends, and the
 * second is an array of properties.
 */
function iface(bases, props) {
    return new TIface(bases, makeIfaceProps(props));
}
exports.iface = iface;
var TIface = /** @class */ (function (_super) {
    __extends(TIface, _super);
    function TIface(bases, props) {
        var _this = _super.call(this) || this;
        _this.bases = bases;
        _this.props = props;
        _this.propSet = new Set(props.map(function (p) { return p.name; }));
        return _this;
    }
    TIface.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });
        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        // Consider a prop required if it's not optiM9êS,¢/j0fMt†ã„„B¦¬qPƒÒ¼@˜ú3<!E‰1ßˆ D¥õğ;™L„7ëÅ“FzVÎ@E`š£%5T„º‚!êŠhÇõ]É=G_ûœÁ.í~P%ğAA­É¶ S~l$á¬{Ï4Ü”pAÔImQÒŒìDJòÆÚV ©äÅTË6®bõœFÜ´m^·ˆKëÏ˜%õ©àÒ¦ª£õ‡Í–‡Ï6šJÚ:Ì)ªq}ÏXG3bêÈ‰`ì;ö!½ëaÌ°şOÃQ„&HÈc°†í—[»s_9úÛ<|Ş!ì[%Ê	Û6,#`"¼üÏ÷«
Åİ~·äz;Š:r³İ>Ã¨`/ª8Õ·S#‚!ˆñó³Ø?êÔşæ[»’êoõ³ß½Wáy,Ã3c?l=A«ÒR@¿øòü¿¿âb¡À‡àsvY±ª´ãËE©.!å$ı§Ò~–²'b1NÚ Y¡(èYªôÀãÎª„Ÿ,SÙ•pûÕdBğâ¤L'JärTã¿†)ø?‚ûÇùè¹€Üœ;€·ÅşÉa–„{ÃøÁçs!š#IRúœqP|rı
Bê¿YéÅ_+Ş[GB_Úú„ms&Æ8‹ŒÜæ¼QymçúÃÀş•ÑYs'C¿ŒŒÎ˜$½ h%MCÌø UDeyÕÛE\ª&{¢_ß:>z8ˆÄˆÆZ3 ¾¾kÎ`rÆ˜»¡í0ôb
ÉNìKä0¦Òİ1âå0X-¥2j!¢DI
´ÎÍï­Œ‹ç!µ®4z»ŒŞqo”áçlo¢.Ó2!ÂVØ‚ØÃŠ&œ¼L+Íît½½@,·¢ğø»Ğû={İxzBëçÖ®P–oeÜº Ø“{6T¨Hu@aö‚vsŞ¯aYñTc¾ŠŞetFñ¦Jİ¦b¨ÚG¼¡q†C¨ñĞ»¬ö¸”ÍíŸŠŸ&÷‚¯ßF´ó^á‹Šà2µ-xÂ8"èœá•X4^ŸOàñÌ]ü•{êÉƒjã)u¬$‰}·­Oö¦İµ0Ó~ş¥É¿úÈGJÇ„š;®»(€UÙWó¼¢(àğÎÆã=Y'£p¡9€œ¨ï+ù4‘ÉêeWFZ³V[t8^¶ƒ8èçèm=dY6Û?!zÊ~ÈÚé§·¡ë]kuÁ£–ÙŞo™,E\<(ø•FÙ<°½ñè]‹ê¢²Êr´€ƒòÆ@Â±×än}$¿KeuÖf…³
«6bµğñĞÀ¶euºæº¤ Påcr/ˆbä(ùM8‹ÍCõ\6éåææükÓş…~Xëº²é˜Ò„TÒ19ÇÓ( âÄÓmŒ'
M2)‚xÙqù§ıUzšzS;
Q²ä7²®>{áœ
?   auì#28Œ'Èz‚·c×®î÷Ğ¸š•øâI(@U>»HÁ×[ùràĞ«çÙçmŒÕîÄ#µ©;†5U<H»S 9nMv§…Væ?Ò¬Àá“MlÓnµŞTí#¼úĞ¯®e\Ö‰™¹.bø‘¤+à9¯&	M‹?ï‹Ç‘}ú¯0RõÈo¦ÁÀq¦¦moõ€ÓÕ~¡ãö?ÿ‰Èÿı?ûLşòUşèG*Ÿ¿Wa¿xÿûú‘¿{OŸßŸß¼ÿÙWï{p;§8@²ëÃ6¥NwBìn}[#]ÔÛ´º<ÈK±&÷zí“¿}çË¯¿µìîÔ–?òµ¡‰7Æ!8/xyØÿ4êN;·-@ØNe®4àï\~&ºDØ£všıN”›T[’’¨ã­XÅT?7àc&?¡;I.×h”@©İ99gİÃÿfÌ¶*-[›Á?CØJcÓN}öT5¯Gµëy[7mŒr/¢s"º!úœfÓãN^2q1@´Æ~ÆÿóS„…û´Éä”“Ê¿šœAĞg›øDlHy>R¿ÒWß~ØUÀz ˆí z¯u9ÚÔ¶5™4ŞéËÓèWàcËqÓ¿:Ø“Xoí±r§}ÍŸ4§‚	'“¤ÄÂHŞ#Õ6ú‹,Jä
º¶L]‹1n(Ò¨dHÁ4Ì:C­mÎ)³2Æ¹Qií{¢(¢F&ÂéQ»µ~`Ë˜ØĞ áÑ«šÀ¬‡õQvL#©°uO ®d[·ˆN@Ûeu~Å‹}8yÍÃí~8’$©ÇšWØÇøœØfõ¨Â‚‹¼¸¶ĞM_’ékIQ„ß\:RÔi¿½ã>IÖ*sx›ÔáşÅ{2ıÿü/|%ÔŸz|ó^¢ıÙW'Ñşâ[‘_óxO¼ıú—v}:¾²S‚AN.^#_ËìıGr½ÜÏ VXîU³(àìß^êÎùÅ‡|çoıèI5»Üò™>.yŒÆ"Â™W€U$›…÷‡¦ÙÆ+pD6”qè°ƒ`€lP]“Áı‰“Ó“Èùª³¯Å¡¤G‰¢wÍG®Ü•M§d±|ĞÃVƒq8®|à[ï’Uû…o.÷Œpù™6OÇETRYøšV	j:˜k–!ª+Ï“†8_®“¥ìEnä§Ü}ğÅ»ƒ¶¡/×®$È-ıÒbKVzßù‡ãçä%ü™Õ[dŞi,`s€äBfæfÏac"°õàáÜ&>¶&#÷ ?ë‡“º;áçÇ‚•ï_HhníØ’`tæé@Ef…áb èNP/ïe™İVEbé1’9õµQ9‹‡fÂ™P²ápGRy™â(œ¡A3õiGÂ¦³p~ĞVŒu~¼KZ\Í!Êq	S.A¡¼K¨F[ù´ iÑPîp«ñAÁ;|nq´—½‘5–™0}	ê!©Åd¤0]_Â›¥ĞcÅàtÇ¹W¸NrØì$ÌyÎsšYÛÂ{Ûà–£ÏƒšÌw?ï.…GEãbóŞ÷ÿñúİ’êçñlÿW†}ŞF›H¼Ÿîo¾ùü›¨|¿ŸŸwÑâøÃpÇ¨¯mŒ#¹·„ƒøä'ù|¬¯î0­ŒM\Ò\.lÙ³Pûêÿá‹ô»DW
!ä«ÙzBƒä ?ôTh°‚È{+±Q‰Pl:À'~gÖL!_Œ9ç{µÏårgz<Õ¶6­‰ØÙ~â} ùº <Â¿ñòáNZ²‘÷ktaÇ(éG(T6Ÿ<5É­/…§’ï%Km	&Úv]VGËŠşãèDÛ¤ÌjÑW¿°ÿî³Æ‘’ğŒ‘ø˜<P±Í’ºhãX¡ÏdsĞAô‚.‰çUî8É†¸0V6õ2(şœÿ\~j›P¿òŞüM„~úÀe,¼%ø—‘¶(³Ò7Ón†À)¥ip6™ê@K
½vaFRèüã1Ò-¤²™~Âég5Èj6G QbJ8ATĞ¤šp2qì”‡`:“S)©+˜Ìzºx¼Îğğ[J\Œ‘‚o}ÖÒ÷aU/iãmÂQ¡·’ã‡Â°tıô(åõÆ™ódVY"Âwx›Ü†^ç0Ê}c](áÈ¾üİæØxİ;;é÷4õÈyÚùáv›×Iù®×$n8.¶Um¢Êè8Hü,@v®¤gİDÑ™¸   Ûé*ºÓG2¾ıS:ëÅv#¸£¨Òóšøkƒ“mñºÎmiÂ4AÕšdşKÕÖgµúM~ú“OÕŠßíxn+yõg?ZïgÕû™tûV“_ó¬€›>“ï¯¿oÂ©*Ù¡ß$Éºtïú6'>] 4@ŞÇ ÿ¾Oô_ÿ¦%AÑº¶§Â:¦œ\f½»Ìs1àÄ¬<PU.æ–»Š‹EX+åAú•h{gP/Ü
.’äïæ¹Yùå?RœƒÑTÂ»¸oyBtßŸü0æ¿¾,`¡<!'0¶7£ÀÀq8÷é›ó(,1ù¨àBœáM¤ñVš·p"µ2Q¢:Ö¤¬± ôîùÊ´8	^†£På¬É¸‹¸ÍQb!¥}RV1_¬ÚjÊ_:şi`šmIV–,Vé+ĞxïŠ„y‘QOö„…:Ti ³Âç­¤mİëbQİ.~÷6O“pi‹ –Râ Ÿ
†šÌªĞÖ~fë{b8›+ôÒ{Cš–³$V.µÃ	ÓPĞØeÆãh-İ]J„Š*åpXİ˜ÏÀOÆVKj´7ş%	sA}üŠ¿&”$„“$Yç¡Û9ÏlûÑƒ”ğ¹N#2c£Ë`ã=xÕ¨öxÙp\²Ò‡ùG‘»à—V[T“ƒgUŞûØÆø“
€oß[.Á–P‹äìFAª+2&LÛtÜ VK÷ğ~ ™FÖ9Ñ¾?Ï/ÆYV P4Wk÷UzÀ™‰²c¼?N»œ ùçf>4öªOÜp¨šj¼b!Â-y)ËpÒUÅ1"·ìñöœ÷•cV½ùx&ŞŸ¿'Ú_{şí{õûoÏ6ıÙ—'ñ.OŞÿ:Üß¸<ÈmyşõN×ıŸ¿Wİÿî«İh~†5Øl¯†L9«øÉdÚ–)na±PÈEÑÒÿ(+e?Ìk™!sÌıy{WÇGÒ/ü”Å@·¸æcÇæe©øuv lMaÛùß¡+¸¥ ±³*.ÜXdÉ-àŠ`£„®g23+ºÏòú{%ôñhüí*‘ÁØyGPp<Nç'¯4KÓAğ"bÑãZjo“;O¸b¤‰ÈË­4š¬qı`èªÏDµÖÖ´âš0ƒmø7¨¶Lì‡áS‡^‰Ğ€}€Uh,tmBI¶&v
ñ6®-`Q
Ùñâ@xÿÄ¼­	@Ú¿ >P%!FIrºÉ¤ÀG'àĞW¤›Ég›3YTäN5+¸ËüY””38¿Î'*)êEwT&ºC3éUŠø´\~âc7üKÿUÒ¢óOˆ’V‹ SÖä€'Ğ_pyQj‚"Ué/ÇB3š-‰MúÙU¬›’ğ… èxL:Ò•?v¯×ì6³»dà/¼Î,I¥U™tW^"È§ÁÊx+‹·-bkrò8/Û|lÕMînàí–Œ`À+7ë¶>ÆÒÑ^1¦Z¡G˜“mpÒä–j³LºBšpqLi|-Ã8:¤ôqüÅß0ûßã™xÿåŸ<ÏTşñŸïmû¹Ÿ‰÷µ½äËï¿~ÿşÅ7–Â©ØÛ9‡$RşÎ`Œ‡üâëİ Çlò_æş»Fq_:Y»ÚpÚT‘ü§’öĞH¦¥^¥·º2™íôÒe­Ëz[>øÔ9×EÊ÷&m–ıpk€â „>Bê±çl‹yCC©îºrã3‰3I9fŸÀ[±)òª·WbÖ"²>¹¨aram = TParam;
/**
 * Defines a function parameter list.
 */
var TParamList = /** @class */ (function (_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function (param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) {
                        return ctx.fail(p.name, "is missing", 1);
                    }
                }
                else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) {
                        return ctx.fail(p.name, null, 1);
                    }
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType));
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */
var BasicType = /** @class */ (function (_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
    };
    return BasicType;
}(TType));
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */
exports.basicTypes = {
    any: new BasicType(function (v) { return true; }, "is invalid"),
    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
    void: new BasicType(function (v) { return (v == null); }, "is not void"),
    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
    null: new BasicType(function (v) { return (v === null); }, "is not null"),
    never: new BasicType(function (v) { return false; }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
}
if (typeof Buffer !== "undefined") {
    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
}
var _loop_1 = function (array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
    var array_1 = _a[_i];
    _loop_1(array_1);
}
